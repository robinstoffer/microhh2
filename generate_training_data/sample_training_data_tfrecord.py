#Script to generate samples from training data (netCDF-file produced by func_generate_training.py).
import numpy as np
import warnings
import netCDF4 as nc
import os
import tensorflow as tf
from sklearn.utils import shuffle

def generate_samples(output_directory, training_filepath = 'training_data.nc', samples_filepath = 'samples_training.nc', means_stdev_filepath = 'means_stdevs_allfields.nc', create_tfrecord = True, store_means_stdevs = True):
    ''' Generate training samples from training data stored as netCDF file in training_filepath (which should be generated by func_generate_training.py), and store them in binary TFRecords files. \\
    NOTE1: the size of the samples is already defined while generating the training data with func_generate_training.py since this determines the number of required ghost cells. \\
    The inputs are: \\
    -output_directory: string specifying the output directory where the generated samples are stored. \\
    -training_filepath: string specifying a netCDF file generated with func_generate_training.py in which the training flow fields are stored. \\
    -samples_filepath: string specifying the name of the file in which the samples are stored. \\
    -means_stdev_filepath: string specifying the filepath where (optionally) the means and stdevs of the training flow fields are stored, which are used by MLP_estimator.py to normalize the input and output data. \\
    -create_tfrecord: a boolean flag specifying whether the samples should be stored in binary TFRecords files. \\
    -store_means_stdevs: a boolean flag specifying whether the means and stdevs of the training data should be stored for each time step, which is needed to normalize the data.'''


    #Check types input
    if not isinstance(output_directory,str):
        raise TypeError("Specified output directory should be a string.")
        
    if not isinstance(training_filepath,str):
        raise TypeError("Specified training filepath should be a string.")
        
    if not isinstance(samples_filepath,str):
        raise TypeError("Specified samples filepath should be a string.")
    
    if not isinstance(means_stdev_filepath,str):
        raise TypeError("Specified means_stdev filepath should be a string.")
    
    if not isinstance(create_tfrecord,bool):
        raise TypeError("Specified create_tfrecord flag should be a boolean.")
    
    if not isinstance(store_means_stdevs,bool):
        raise TypeError("Specified store_means_stdevs flag should be a boolean.")

    #Fetch training data
    a = nc.Dataset(training_filepath, 'r')

    #Read ghost cells, indices, and coordinates from the training file
    igc        = int(a['igc'][:])
    jgc        = int(a['jgc'][:])
    kgc_center = int(a['kgc_center'][:])
    kgc_edge   = int(a['kgc_edge'][:])
    iend       = int(a['iend'][:])
    jend       = int(a['jend'][:])
    kend       = int(a['kend'][:])
    khend      = int(a['khend'][:])
    zhc        = np.array(a['zhc'][:])
    zc         = np.array(a['zc'][:])
    yhc        = np.array(a['yhc'][:])
    yc         = np.array(a['yc'][:])
    xhc        = np.array(a['xhc'][:])
    xc         = np.array(a['xc'][:])
    zhgc       = np.array(a['zhgc'][:])
    zgc        = np.array(a['zgc'][:])
    yhgc       = np.array(a['yhgc'][:])
    ygc        = np.array(a['ygc'][:])
    xhgc       = np.array(a['xhgc'][:])
    xgc        = np.array(a['xgc'][:])

    #Define shapes of output arrays based on stored training data
    nt = a['unres_tau_xu_tot'].shape[0] # NOTE1: nt should be the same for all variables.
    nz = zc.shape[0]
    ny = yc.shape[0]
    nx = xc.shape[0]
    size_samples = int(a['size_samples'][:])
    cells_around_centercell = int(a['cells_around_centercell'][:])
    if nz < size_samples:
        raise RuntimeError("The number of vertical layers should at least be equal to the specified sample size.")
    nsamples = (nz+50) * ny * nx #Add 50 to account for preferential sampling
    
    #Define arrays to store means and stdevs according to store_means_stdevs flag
    if store_means_stdevs:
        mean_uc = np.zeros((nt,1))
        mean_vc = np.zeros((nt,1))
        mean_wc = np.zeros((nt,1))
        #
        mean_unres_tau_xu = np.zeros((nt,1))
        mean_unres_tau_yu = np.zeros((nt,1))
        mean_unres_tau_zu = np.zeros((nt,1))
        mean_unres_tau_xv = np.zeros((nt,1))
        mean_unres_tau_yv = np.zeros((nt,1))
        mean_unres_tau_zv = np.zeros((nt,1))
        mean_unres_tau_xw = np.zeros((nt,1))
        mean_unres_tau_yw = np.zeros((nt,1))
        mean_unres_tau_zw = np.zeros((nt,1))
        #
        stdev_uc = np.zeros((nt,1))
        stdev_vc = np.zeros((nt,1))
        stdev_wc = np.zeros((nt,1))
        #
        stdev_unres_tau_xu = np.zeros((nt,1))
        stdev_unres_tau_yu = np.zeros((nt,1))
        stdev_unres_tau_zu = np.zeros((nt,1))
        stdev_unres_tau_xv = np.zeros((nt,1))
        stdev_unres_tau_yv = np.zeros((nt,1))
        stdev_unres_tau_zv = np.zeros((nt,1))
        stdev_unres_tau_xw = np.zeros((nt,1))
        stdev_unres_tau_yw = np.zeros((nt,1))
        stdev_unres_tau_zw = np.zeros((nt,1))

    #Loop over timesteps, take for each timestep samples of size_samples*size_samples*size_samples
    tot_sample_num = 0
    for t in range(nt):
        #Define some auxilary variables to keep track of sample numbers
        tot_sample_begin = tot_sample_num #
        sample_num = 0
        
        #Define variables for storage
        uc_samples = np.zeros((nsamples,size_samples,size_samples,size_samples))
        vc_samples = np.zeros((nsamples,size_samples,size_samples,size_samples))
        wc_samples = np.zeros((nsamples,size_samples,size_samples,size_samples))
        #
        unres_tau_xu_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_xv_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_xw_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_yu_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_yv_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_yw_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_zu_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_zv_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_zw_samples_upstream   = np.zeros((nsamples,1))
        unres_tau_xu_samples_downstream = np.zeros((nsamples,1))
        unres_tau_xv_samples_downstream = np.zeros((nsamples,1))
        unres_tau_xw_samples_downstream = np.zeros((nsamples,1))
        unres_tau_yu_samples_downstream = np.zeros((nsamples,1))
        unres_tau_yv_samples_downstream = np.zeros((nsamples,1))
        unres_tau_yw_samples_downstream = np.zeros((nsamples,1))
        unres_tau_zu_samples_downstream = np.zeros((nsamples,1))
        unres_tau_zv_samples_downstream = np.zeros((nsamples,1))
        unres_tau_zw_samples_downstream = np.zeros((nsamples,1))
        
        #Define flags to indicate whether samples are located at the bottom or top wall, as those require special treatment
        flag_topwall_samples            = np.zeros((nsamples,1))
        flag_bottomwall_samples         = np.zeros((nsamples,1))
        
        #Read variables from netCDF-file
        uc_singlefield = np.array(a['uc'][t,:,:,:])
        vc_singlefield = np.array(a['vc'][t,:,:,:])
        wc_singlefield = np.array(a['wc'][t,:,:,:])

        unres_tau_xu_singlefield = np.array(a["unres_tau_xu_tot"][t,:,:,:])
        unres_tau_xv_singlefield = np.array(a["unres_tau_xv_tot"][t,:,:,:])
        unres_tau_xw_singlefield = np.array(a["unres_tau_xw_tot"][t,:,:,:])
        unres_tau_yu_singlefield = np.array(a["unres_tau_yu_tot"][t,:,:,:])
        unres_tau_yv_singlefield = np.array(a["unres_tau_yv_tot"][t,:,:,:])
        unres_tau_yw_singlefield = np.array(a["unres_tau_yw_tot"][t,:,:,:])
        unres_tau_zu_singlefield = np.array(a["unres_tau_zu_tot"][t,:,:,:])
        unres_tau_zv_singlefield = np.array(a["unres_tau_zv_tot"][t,:,:,:])
        unres_tau_zw_singlefield = np.array(a["unres_tau_zw_tot"][t,:,:,:])

        #Define arrays to store for each sample the locations and time step
        tstep_samples  = np.zeros((nsamples,1))
        zhloc_samples  = np.zeros((nsamples,1))
        zloc_samples   = np.zeros((nsamples,1))
        yhloc_samples  = np.zeros((nsamples,1))
        yloc_samples   = np.zeros((nsamples,1))
        xhloc_samples  = np.zeros((nsamples,1))
        xloc_samples   = np.zeros((nsamples,1))

        #Calculate means and stdevs according to store_means_stdevs flag
        #NOTE: remove ghost cells when calculating the means+stdevs
        if store_means_stdevs:
            mean_uc[t] = np.mean(uc_singlefield[kgc_center:kend,jgc:jend,igc:iend])
            mean_vc[t] = np.mean(vc_singlefield[kgc_center:kend,jgc:jend,igc:iend])
            mean_wc[t] = np.mean(wc_singlefield[kgc_edge:khend,jgc:jend,igc:iend])
            #
            mean_unres_tau_xu[t] = np.mean(unres_tau_xu_singlefield[:,:,1:])
            mean_unres_tau_yu[t] = np.mean(unres_tau_yu_singlefield)
            mean_unres_tau_zu[t] = np.mean(unres_tau_zu_singlefield)
            mean_unres_tau_xv[t] = np.mean(unres_tau_xv_singlefield)
            mean_unres_tau_yv[t] = np.mean(unres_tau_yv_singlefield[:,1:,:])
            mean_unres_tau_zv[t] = np.mean(unres_tau_zv_singlefield)
            mean_unres_tau_xw[t] = np.mean(unres_tau_xw_singlefield)
            mean_unres_tau_yw[t] = np.mean(unres_tau_yw_singlefield)
            mean_unres_tau_zw[t] = np.mean(unres_tau_zw_singlefield[1:,:,:])
            #
            stdev_uc[t] = np.std(uc_singlefield[kgc_center:kend,jgc:jend,igc:iend])
            stdev_vc[t] = np.std(vc_singlefield[kgc_center:kend,jgc:jend,igc:iend])
            stdev_wc[t] = np.std(wc_singlefield[kgc_edge:khend,jgc:jend,igc:iend])
            #
            stdev_unres_tau_xu[t] = np.std(unres_tau_xu_singlefield[:,:,1:])
            stdev_unres_tau_yu[t] = np.std(unres_tau_yu_singlefield)
            stdev_unres_tau_zu[t] = np.std(unres_tau_zu_singlefield)
            stdev_unres_tau_xv[t] = np.std(unres_tau_xv_singlefield)
            stdev_unres_tau_yv[t] = np.std(unres_tau_yv_singlefield[:,1:,:])
            stdev_unres_tau_zv[t] = np.std(unres_tau_zv_singlefield)
            stdev_unres_tau_xw[t] = np.std(unres_tau_xw_singlefield)
            stdev_unres_tau_yw[t] = np.std(unres_tau_yw_singlefield)
            stdev_unres_tau_zw[t] = np.std(unres_tau_zw_singlefield[1:,:,:])

        ###Do the actual sampling.###
        for index_z in range(kgc_center, kend): #NOTE: kgc_center and kgc_edge should be identical
            index_zlow                    = index_z - cells_around_centercell
            index_zhigh                   = index_z + cells_around_centercell + 1 #NOTE: +1 needed to ensure that in the slicing operation the selected number of grid cells above the center grid cell, is equal to the number of grid cells selected below the center grid cell.
            index_z_noghost               = index_z - cells_around_centercell
            for index_y in range(jgc,jend): 
                index_ylow                = index_y - cells_around_centercell
                index_yhigh               = index_y + cells_around_centercell + 1 #NOTE: +1 needed to ensure that in the slicing operation the selected number of grid cells above the center grid cell, is equal to the number of grid cells selected below the center grid cell.
                index_y_noghost           = index_y - jgc
    
                for index_x in range(igc,iend):
                    index_xlow            = index_x - cells_around_centercell
                    index_xhigh           = index_x + cells_around_centercell + 1 #NOTE: +1 needed to ensure that in the slicing operation the selected number of grid cells above the center grid cell, is equal to the number of grid cells selected below the center grid cell.
                    index_x_noghost       = index_x - igc

                    #Add preferential sampling with additional loop, determine first number of additional iterations
                    if (index_z == kgc_center) or (index_z == (kend-1)):
                        pref_iterations = 10;
                    elif (index_z == (kgc_center+1)) or (index_z == (kend-2)):
                        pref_iterations = 8
                    elif (index_z == (kgc_center+2)) or (index_z == (kend-3)):
                        pref_iterations = 6
                    elif (index_z == (kgc_center+3)) or (index_z == (kend-4)):
                        pref_iterations = 4
                    elif (index_z == (kgc_center+4)) or (index_z == (kend-5)):
                        pref_iterations = 2
                    else:
                        pref_iterations = 1
                    
                    for n in range(pref_iterations):

                        #Take samples of size_samples*size_samples*size_samples and store them
                        uc_samples[sample_num,:,:,:]     = uc_singlefield[index_zlow:index_zhigh,index_ylow:index_yhigh,index_xlow:index_xhigh]
                        vc_samples[sample_num,:,:,:]     = vc_singlefield[index_zlow:index_zhigh,index_ylow:index_yhigh,index_xlow:index_xhigh]
                        wc_samples[sample_num,:,:,:]     = wc_singlefield[index_zlow:index_zhigh,index_ylow:index_yhigh,index_xlow:index_xhigh]
                        
                        #Store corresponding unresolved transports
                        unres_tau_xu_samples_upstream[sample_num]   = unres_tau_xu_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_xu_samples_upstream[sample_num]   = unres_tau_xu_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_xv_samples_upstream[sample_num]   = unres_tau_xv_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_xw_samples_upstream[sample_num]   = unres_tau_xw_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_yu_samples_upstream[sample_num]   = unres_tau_yu_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_yv_samples_upstream[sample_num]   = unres_tau_yv_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_yw_samples_upstream[sample_num]   = unres_tau_yw_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]                
                        unres_tau_zu_samples_upstream[sample_num]   = unres_tau_zu_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_zv_samples_upstream[sample_num]   = unres_tau_zv_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_zw_samples_upstream[sample_num]   = unres_tau_zw_singlefield[index_z_noghost,index_y_noghost,index_x_noghost]
                        unres_tau_xu_samples_downstream[sample_num] = unres_tau_xu_singlefield[index_z_noghost,index_y_noghost,index_x_noghost+1]
                        unres_tau_xv_samples_downstream[sample_num] = unres_tau_xv_singlefield[index_z_noghost,index_y_noghost,index_x_noghost+1]
                        unres_tau_xw_samples_downstream[sample_num] = unres_tau_xw_singlefield[index_z_noghost,index_y_noghost,index_x_noghost+1]
                        unres_tau_yu_samples_downstream[sample_num] = unres_tau_yu_singlefield[index_z_noghost,index_y_noghost+1,index_x_noghost]
                        unres_tau_yv_samples_downstream[sample_num] = unres_tau_yv_singlefield[index_z_noghost,index_y_noghost+1,index_x_noghost]
                        unres_tau_yw_samples_downstream[sample_num] = unres_tau_yw_singlefield[index_z_noghost,index_y_noghost+1,index_x_noghost]                
                        unres_tau_zu_samples_downstream[sample_num] = unres_tau_zu_singlefield[index_z_noghost+1,index_y_noghost,index_x_noghost]
                        unres_tau_zv_samples_downstream[sample_num] = unres_tau_zv_singlefield[index_z_noghost+1,index_y_noghost,index_x_noghost]
                        unres_tau_zw_samples_downstream[sample_num] = unres_tau_zw_singlefield[index_z_noghost+1,index_y_noghost,index_x_noghost]
   
                        #Store corresponding locations
                        tstep_samples[sample_num] = int(t)
                        zhloc_samples[sample_num] = zhc[index_z_noghost]
                        zloc_samples[sample_num]  = zc[index_z_noghost]
                        yhloc_samples[sample_num] = yhc[index_y_noghost]
                        yloc_samples[sample_num]  = yc[index_y_noghost]
                        xhloc_samples[sample_num] = xhc[index_x_noghost]
                        xloc_samples[sample_num]  = xc[index_x_noghost]

                        #Set flags of bottom/top wall to one when the samples is located at the bottom/top.
                        if index_z == (kend-1):
                            flag_topwall_samples[sample_num] = 1
                        elif index_z == kgc_center:
                            flag_bottomwall_samples[sample_num] = 1
    
                        sample_num +=1
                        tot_sample_num+=1

        ###
        #Randomly shuffle the input and output data in a consistent manner, such there is no specific order in the samples stored.
        uc_samples, vc_samples, wc_samples, \
        unres_tau_xu_samples_upstream, unres_tau_xv_samples_upstream, unres_tau_xw_samples_upstream, \
        unres_tau_yu_samples_upstream, unres_tau_yv_samples_upstream, unres_tau_yw_samples_upstream, \
        unres_tau_zu_samples_upstream, unres_tau_zv_samples_upstream, unres_tau_zw_samples_upstream, \
        unres_tau_xu_samples_downstream, unres_tau_xv_samples_downstream, unres_tau_xw_samples_downstream, \
        unres_tau_yu_samples_downstream, unres_tau_yv_samples_downstream, unres_tau_yw_samples_downstream, \
        unres_tau_zu_samples_downstream, unres_tau_zv_samples_downstream, unres_tau_zw_samples_downstream, \
        tstep_samples, zhloc_samples, zloc_samples, \
        yhloc_samples, yloc_samples, xhloc_samples, \
        xloc_samples, flag_topwall_samples, flag_bottomwall_samples \
        = shuffle(
        uc_samples, vc_samples, wc_samples,
        unres_tau_xu_samples_upstream, unres_tau_xv_samples_upstream, unres_tau_xw_samples_upstream,
        unres_tau_yu_samples_upstream, unres_tau_yv_samples_upstream, unres_tau_yw_samples_upstream,
        unres_tau_zu_samples_upstream, unres_tau_zv_samples_upstream, unres_tau_zw_samples_upstream,
        unres_tau_xu_samples_downstream, unres_tau_xv_samples_downstream, unres_tau_xw_samples_downstream,
        unres_tau_yu_samples_downstream, unres_tau_yv_samples_downstream, unres_tau_yw_samples_downstream,
        unres_tau_zu_samples_downstream, unres_tau_zv_samples_downstream, unres_tau_zw_samples_downstream,
        tstep_samples, zhloc_samples, zloc_samples,
        yhloc_samples, yloc_samples, xhloc_samples,
        xloc_samples, flag_topwall_samples, flag_bottomwall_samples)

        #Create binary tfrecord files (partly copied from script imagenet_to_gcs.py provided by the Tensorflow authors, 2017
        if create_tfrecord:
    
            def _int64_feature(value):
                """Wrapper for inserting int64 features into Example proto."""
                if not isinstance(value, list):
                    value = [value]
                return tf.train.Feature(int64_list=tf.train.Int64List(value=value))
    
            def _float_feature(value):
                """Wrapper for inserting float features into Example proto."""
                if not isinstance(value,list):
                    value = [value]
                return tf.train.Feature(float_list=tf.train.FloatList(value=value))        
            
            def _convert_to_example(uc_sample, vc_sample, wc_sample, 
                    unres_tau_xu_sample_upstream, unres_tau_xv_sample_upstream, unres_tau_xw_sample_upstream, 
                    unres_tau_yu_sample_upstream, unres_tau_yv_sample_upstream, unres_tau_yw_sample_upstream, 
                    unres_tau_zu_sample_upstream, unres_tau_zv_sample_upstream, unres_tau_zw_sample_upstream,
                    unres_tau_xu_sample_downstream, unres_tau_xv_sample_downstream, unres_tau_xw_sample_downstream, 
                    unres_tau_yu_sample_downstream, unres_tau_yv_sample_downstream, unres_tau_yw_sample_downstream, 
                    unres_tau_zu_sample_downstream, unres_tau_zv_sample_downstream, unres_tau_zw_sample_downstream,
                    x_sample_size, y_sample_size, z_sample_size, 
                    tstep_sample, xloc_sample, xhloc_sample, 
                    yloc_sample, yhloc_sample, zloc_sample, zhloc_sample,
                    flag_topwall_sample, flag_bottomwall_sample):
                """Build a protocol for an individual sample.
                
                The inputs are:
            
                  uc_sample: float, sample of u-component on coarse grid
    
                  vc_sample: float, sample of v-component on coarse grid
    
                  wc_sample: float, sample of w-component on coarse grid
    
                  unres_tau_xu_sample_upstream: float, sample of unres_tau_xu_upstream on coarse grid
    
                  unres_tau_xv_sample_upstream: float, sample of unres_tau_xv_upstream on coarse grid
    
                  unres_tau_xw_sample_upstream: float, sample of unres_tau_xw_upstream on coarse grid
    
                  unres_tau_yu_sample_upstream: float, sample of unres_tau_yu_upstream on coarse grid
    
                  unres_tau_yv_sample_upstream: float, sample of unres_tau_yv_upstream on coarse grid
    
                  unres_tau_yw_sample_upstream: float, sample of unres_tau_yw_upstream on coarse grid
    
                  unres_tau_zu_sample_upstream: float, sample of unres_tau_zu_upstream on coarse grid
    
                  unres_tau_zv_sample_upstream: float, sample of unres_tau_zv_upstream on coarse grid
    
                  unres_tau_zw_sample_upstream: float, sample of unres_tau_zw_upstream on coarse grid
                  
                  unres_tau_xu_sample_downstream: float, sample of unres_tau_xu_downstream on coarse grid
    
                  unres_tau_xv_sample_downstream: float, sample of unres_tau_xv_downstream on coarse grid
    
                  unres_tau_xw_sample_downstream: float, sample of unres_tau_xw_downstream on coarse grid
    
                  unres_tau_yu_sample_downstream: float, sample of unres_tau_yu_downstream on coarse grid
    
                  unres_tau_yv_sample_downstream: float, sample of unres_tau_yv_downstream on coarse grid
    
                  unres_tau_yw_sample_downstream: float, sample of unres_tau_yw_downstream on coarse grid
    
                  unres_tau_zu_sample_downstream: float, sample of unres_tau_zu_downstream on coarse grid
    
                  unres_tau_zv_sample_downstream: float, sample of unres_tau_zv_downstream on coarse grid
    
                  unres_tau_zw_sample_downstream: float, sample of unres_tau_zw_downstream on coarse grid
    
                  x_sample_size: integer, number of grid cells in x-direction selected in sample
    
                  y_sample_size: integer, number of grid cells in y-direction selected in sample
    
                  z_sample_size: integer, number of grid cells in z-direction selected in sample

                  tstep_sample:  float, time step of sample
                  
                  xloc_sample:   float, location of sample in x-direction

                  xhloc_sample:  float, location of sample in xh-direction

                  yloc_sample:   float, location of sample in y-direction
                  
                  yhloc_sample:  float, location of sample in yh-direction
     
                  zloc_sample:   float, location of sample in z-direction
                
                  zhloc_sample:  float, location of sample in zh-direction

                  flag_topwall_sample: integer, flag indicating wheter loc is at the top wall

                  flag_bottomwall_sample: integer, flag indicating wheter loc is at the bottom wall
                
                Returns:

                  Example protocol
                """
            
                example = tf.train.Example(features=tf.train.Features(feature={
                               'uc_sample': _float_feature(uc_sample.flatten().tolist()),
                               'vc_sample': _float_feature(vc_sample.flatten().tolist()),
                               'wc_sample': _float_feature(wc_sample.flatten().tolist()),
                               'unres_tau_xu_sample_upstream': _float_feature(unres_tau_xu_sample_upstream.flatten().tolist()),
                               'unres_tau_xv_sample_upstream': _float_feature(unres_tau_xv_sample_upstream.flatten().tolist()),
                               'unres_tau_xw_sample_upstream': _float_feature(unres_tau_xw_sample_upstream.flatten().tolist()),
                               'unres_tau_yu_sample_upstream': _float_feature(unres_tau_yu_sample_upstream.flatten().tolist()),
                               'unres_tau_yv_sample_upstream': _float_feature(unres_tau_yv_sample_upstream.flatten().tolist()),
                               'unres_tau_yw_sample_upstream': _float_feature(unres_tau_yw_sample_upstream.flatten().tolist()),
                               'unres_tau_zu_sample_upstream': _float_feature(unres_tau_zu_sample_upstream.flatten().tolist()),
                               'unres_tau_zv_sample_upstream': _float_feature(unres_tau_zv_sample_upstream.flatten().tolist()),
                               'unres_tau_zw_sample_upstream': _float_feature(unres_tau_zw_sample_upstream.flatten().tolist()),
                               'unres_tau_xu_sample_downstream': _float_feature(unres_tau_xu_sample_downstream.flatten().tolist()),
                               'unres_tau_xv_sample_downstream': _float_feature(unres_tau_xv_sample_downstream.flatten().tolist()),
                               'unres_tau_xw_sample_downstream': _float_feature(unres_tau_xw_sample_downstream.flatten().tolist()),
                               'unres_tau_yu_sample_downstream': _float_feature(unres_tau_yu_sample_downstream.flatten().tolist()),
                               'unres_tau_yv_sample_downstream': _float_feature(unres_tau_yv_sample_downstream.flatten().tolist()),
                               'unres_tau_yw_sample_downstream': _float_feature(unres_tau_yw_sample_downstream.flatten().tolist()),
                               'unres_tau_zu_sample_downstream': _float_feature(unres_tau_zu_sample_downstream.flatten().tolist()),
                               'unres_tau_zv_sample_downstream': _float_feature(unres_tau_zv_sample_downstream.flatten().tolist()),
                               'unres_tau_zw_sample_downstream': _float_feature(unres_tau_zw_sample_downstream.flatten().tolist()),
                               'x_sample_size': _int64_feature(x_sample_size),
                               'y_sample_size': _int64_feature(y_sample_size),
                               'z_sample_size': _int64_feature(z_sample_size),
                               'tstep_sample' : _int64_feature(tstep_sample),
                               'flag_topwall_sample': _int64_feature(flag_topwall_sample),
                               'flag_bottomwall_sample': _int64_feature(flag_bottomwall_sample),
                               'xloc_sample'  : _float_feature(xloc_sample),
                               'xhloc_sample' : _float_feature(xhloc_sample),
                               'yloc_sample'  : _float_feature(yloc_sample),
                               'yhloc_sample' : _float_feature(yhloc_sample),
                               'zloc_sample'  : _float_feature(zloc_sample),
                               'zhloc_sample' : _float_feature(zhloc_sample)}))        
                return example
            
            def _process_image_files_batch(output_file, uc_samples, vc_samples, wc_samples, 
                    unres_tau_xu_samples_upstream, unres_tau_xv_samples_upstream, unres_tau_xw_samples_upstream, 
                    unres_tau_yu_samples_upstream, unres_tau_yv_samples_upstream, unres_tau_yw_samples_upstream, 
                    unres_tau_zu_samples_upstream, unres_tau_zv_samples_upstream, unres_tau_zw_samples_upstream, 
                    unres_tau_xu_samples_downstream, unres_tau_xv_samples_downstream, unres_tau_xw_samples_downstream, 
                    unres_tau_yu_samples_downstream, unres_tau_yv_samples_downstream, unres_tau_yw_samples_downstream, 
                    unres_tau_zu_samples_downstream, unres_tau_zv_samples_downstream, unres_tau_zw_samples_downstream, 
                    x_sample_size, y_sample_size, z_sample_size, 
                    tstep_samples, xloc_samples, xhloc_samples, 
                    yloc_samples, yhloc_samples, zloc_samples, zhloc_samples,
                    flag_topwall_samples, flag_bottomwall_samples):
            
                """Processes and saves samples in TFrecord format.
            
                The inputs are:
            
                  output_file: string, name of file in which the samples are stored
            
                  uc_samples: float, samples of u-component on coarse grid
    
                  vc_samples: float, samples of v-component on coarse grid
    
                  wc_samples: float, samples of w-component on coarse grid
    
                  unres_tau_xu_samples_upstream: float, samples of unres_tau_xu_upstream on coarse grid
    
                  unres_tau_xv_samples_upstream: float, samples of unres_tau_xv_upstream on coarse grid
    
                  unres_tau_xw_samples_upstream: float, samples of unres_tau_xw_upstream on coarse grid
    
                  unres_tau_yu_samples_upstream: float, samples of unres_tau_yu_upstream on coarse grid
    
                  unres_tau_yv_samples_upstream: float, samples of unres_tau_yv_upstream on coarse grid
    
                  unres_tau_yw_samples_upstream: float, samples of unres_tau_yw_upstream on coarse grid
    
                  unres_tau_zu_samples_upstream: float, samples of unres_tau_zu_upstream on coarse grid
    
                  unres_tau_zv_samples_upstream: float, samples of unres_tau_zv_upstream on coarse grid
    
                  unres_tau_zw_samples_upstream: float, samples of unres_tau_zw_upstream on coarse grid
                  
                  unres_tau_xu_samples_downstream: float, samples of unres_tau_xu_downstream on coarse grid
    
                  unres_tau_xv_samples_downstream: float, samples of unres_tau_xv_downstream on coarse grid
    
                  unres_tau_xw_samples_downstream: float, samples of unres_tau_xw_downstream on coarse grid
    
                  unres_tau_yu_samples_downstream: float, samples of unres_tau_yu_downstream on coarse grid
    
                  unres_tau_yv_samples_downstream: float, samples of unres_tau_yv_downstream on coarse grid
    
                  unres_tau_yw_samples_downstream: float, samples of unres_tau_yw_downstream on coarse grid
    
                  unres_tau_zu_samples_downstream: float, samples of unres_tau_zu_downstream on coarse grid
    
                  unres_tau_zv_samples_downstream: float, samples of unres_tau_zv_downstream on coarse grid
    
                  unres_tau_zw_samples_downstream: float, samples of unres_tau_zw_downstream on coarse grid
    
                  x_sample_size: integer, number of grid cells in x-direction selected in samples
    
                  y_sample_size: integer, number of grid cells in y-direction selected in samples
    
                  z_sample_size: integer, number of grid cells in z-direction selected in samples

                  tstep_samples:  float, time step of sample
                  
                  xloc_samples:   float, location of samples in x-direction

                  xhloc_samples:  float, location of samples in xh-direction

                  yloc_samples:   float, location of samples in y-direction
                  
                  yhloc_samples:  float, location of samples in yh-direction
     
                  zloc_samples:   float, location of samples in z-direction
                
                  zhloc_samples:  float, location of samples in zh-direction

                  flag_topwall_samples: integer, flag indicating wheter loc is at the top wall

                  flag_bottomwall_samples: integer, flag indicating wheter loc is at the bottom wall
                """
                writer = tf.python_io.TFRecordWriter(output_file)
    
                for uc_sample, vc_sample, wc_sample, \
                unres_tau_xu_sample_upstream, unres_tau_xv_sample_upstream, unres_tau_xw_sample_upstream, \
                unres_tau_yu_sample_upstream, unres_tau_yv_sample_upstream, unres_tau_yw_sample_upstream, \
                unres_tau_zu_sample_upstream, unres_tau_zv_sample_upstream, unres_tau_zw_sample_upstream, \
                unres_tau_xu_sample_downstream, unres_tau_xv_sample_downstream, unres_tau_xw_sample_downstream, \
                unres_tau_yu_sample_downstream, unres_tau_yv_sample_downstream, unres_tau_yw_sample_downstream, \
                unres_tau_zu_sample_downstream, unres_tau_zv_sample_downstream, unres_tau_zw_sample_downstream, \
                tstep_sample, xloc_sample, xhloc_sample, \
                yloc_sample, yhloc_sample, zloc_sample, zhloc_sample, \
                flag_topwall_sample, flag_bottomwall_sample in zip(
                        uc_samples, vc_samples, wc_samples, 
                        unres_tau_xu_samples_upstream, unres_tau_xv_samples_upstream, unres_tau_xw_samples_upstream, 
                        unres_tau_yu_samples_upstream, unres_tau_yv_samples_upstream, unres_tau_yw_samples_upstream, 
                        unres_tau_zu_samples_upstream, unres_tau_zv_samples_upstream, unres_tau_zw_samples_upstream, 
                        unres_tau_xu_samples_downstream, unres_tau_xv_samples_downstream, unres_tau_xw_samples_downstream, 
                        unres_tau_yu_samples_downstream, unres_tau_yv_samples_downstream, unres_tau_yw_samples_downstream, 
                        unres_tau_zu_samples_downstream, unres_tau_zv_samples_downstream, unres_tau_zw_samples_downstream, 
                        tstep_samples, xloc_samples, xhloc_samples, 
                        yloc_samples, yhloc_samples, zloc_samples, zhloc_samples,
                        flag_topwall_samples, flag_bottomwall_samples):
                    
                    example = _convert_to_example(uc_sample, vc_sample, wc_sample, 
                              unres_tau_xu_sample_upstream, unres_tau_xv_sample_upstream, unres_tau_xw_sample_upstream, 
                              unres_tau_yu_sample_upstream, unres_tau_yv_sample_upstream, unres_tau_yw_sample_upstream, 
                              unres_tau_zu_sample_upstream, unres_tau_zv_sample_upstream, unres_tau_zw_sample_upstream, 
                              unres_tau_xu_sample_downstream, unres_tau_xv_sample_downstream, unres_tau_xw_sample_downstream, 
                              unres_tau_yu_sample_downstream, unres_tau_yv_sample_downstream, unres_tau_yw_sample_downstream, 
                              unres_tau_zu_sample_downstream, unres_tau_zv_sample_downstream, unres_tau_zw_sample_downstream, 
                              x_sample_size, y_sample_size, z_sample_size, 
                              tstep_sample, xloc_sample, xhloc_sample, 
                              yloc_sample, yhloc_sample, zloc_sample, zhloc_sample,
                              flag_topwall_sample, flag_bottomwall_sample)
                    
                    writer.write(example.SerializeToString())
            
                writer.close()
            
            #Create training data based on absolute wind velocities, store in groups of 1000 samples except last file
            nsamples_per_tfrecord = 1000
            tot_num_files = (nsamples // nsamples_per_tfrecord) + 1
            for num_file in range(tot_num_files):
                
                output_file = os.path.join(output_directory, '{}_time_step_{}_of_{}_file_{}_numsamples_1000.tfrecords'.format('training', t+1, nt, num_file+1))
                
                if num_file == (tot_num_files - 1):
                    slice_samples = np.s_[num_file * nsamples_per_tfrecord:] #Select all remaining samples, which should be less than 10000
                else:
                    slice_samples = np.s_[num_file * nsamples_per_tfrecord: (num_file+1) * nsamples_per_tfrecord]

                _process_image_files_batch(output_file, uc_samples[slice_samples], vc_samples[slice_samples], wc_samples[slice_samples], 
                        unres_tau_xu_samples_upstream[slice_samples], unres_tau_xv_samples_upstream[slice_samples], unres_tau_xw_samples_upstream[slice_samples], 
                        unres_tau_yu_samples_upstream[slice_samples], unres_tau_yv_samples_upstream[slice_samples], unres_tau_yw_samples_upstream[slice_samples], 
                        unres_tau_zu_samples_upstream[slice_samples], unres_tau_zv_samples_upstream[slice_samples], unres_tau_zw_samples_upstream[slice_samples], 
                        unres_tau_xu_samples_downstream[slice_samples], unres_tau_xv_samples_downstream[slice_samples], unres_tau_xw_samples_downstream[slice_samples], 
                        unres_tau_yu_samples_downstream[slice_samples], unres_tau_yv_samples_downstream[slice_samples], unres_tau_yw_samples_downstream[slice_samples], 
                        unres_tau_zu_samples_downstream[slice_samples], unres_tau_zv_samples_downstream[slice_samples], unres_tau_zw_samples_downstream[slice_samples], 
                        size_samples, size_samples, size_samples, 
                        tstep_samples[slice_samples], xloc_samples[slice_samples], xhloc_samples[slice_samples], 
                        yloc_samples[slice_samples], yhloc_samples[slice_samples], zloc_samples[slice_samples], zhloc_samples[slice_samples],
                        flag_topwall_samples[slice_samples], flag_bottomwall_samples[slice_samples])

                print('Finished writing file: %s' % output_file)

    #Close data file
    a.close()

    #Store means and stdevs of all fields in separate nc-file if required by store_means_stdevs flag.
    #NOTE: arrays exist of single dimension, ranked according to time step.
    if store_means_stdevs:
        means_stdev_file = nc.Dataset(means_stdev_filepath, 'w')
        
        #Create new dimension
        means_stdev_file.createDimension("nt", nt)

        #Create new variables
        varmeanuc            = means_stdev_file.createVariable("mean_uc","f8",("nt",))
        varmeanvc            = means_stdev_file.createVariable("mean_vc","f8",("nt",))
        varmeanwc            = means_stdev_file.createVariable("mean_wc","f8",("nt",))
        varmeanunrestauxu    = means_stdev_file.createVariable("mean_unres_tau_xu_sample","f8",("nt",))
        varmeanunrestauyu    = means_stdev_file.createVariable("mean_unres_tau_yu_sample","f8",("nt",))
        varmeanunrestauzu    = means_stdev_file.createVariable("mean_unres_tau_zu_sample","f8",("nt",))
        varmeanunrestauxv    = means_stdev_file.createVariable("mean_unres_tau_xv_sample","f8",("nt",))
        varmeanunrestauyv    = means_stdev_file.createVariable("mean_unres_tau_yv_sample","f8",("nt",))
        varmeanunrestauzv    = means_stdev_file.createVariable("mean_unres_tau_zv_sample","f8",("nt",))
        varmeanunrestauxw    = means_stdev_file.createVariable("mean_unres_tau_xw_sample","f8",("nt",))
        varmeanunrestauyw    = means_stdev_file.createVariable("mean_unres_tau_yw_sample","f8",("nt",))
        varmeanunrestauzw    = means_stdev_file.createVariable("mean_unres_tau_zw_sample","f8",("nt",))

        varstdevuc           = means_stdev_file.createVariable("stdev_uc","f8",("nt",))
        varstdevvc           = means_stdev_file.createVariable("stdev_vc","f8",("nt",))
        varstdevwc           = means_stdev_file.createVariable("stdev_wc","f8",("nt",))
        varstdevunrestauxu   = means_stdev_file.createVariable("stdev_unres_tau_xu_sample","f8",("nt",))
        varstdevunrestauyu   = means_stdev_file.createVariable("stdev_unres_tau_yu_sample","f8",("nt",))
        varstdevunrestauzu   = means_stdev_file.createVariable("stdev_unres_tau_zu_sample","f8",("nt",))
        varstdevunrestauxv   = means_stdev_file.createVariable("stdev_unres_tau_xv_sample","f8",("nt",))
        varstdevunrestauyv   = means_stdev_file.createVariable("stdev_unres_tau_yv_sample","f8",("nt",))
        varstdevunrestauzv   = means_stdev_file.createVariable("stdev_unres_tau_zv_sample","f8",("nt",))
        varstdevunrestauxw   = means_stdev_file.createVariable("stdev_unres_tau_xw_sample","f8",("nt",))
        varstdevunrestauyw   = means_stdev_file.createVariable("stdev_unres_tau_yw_sample","f8",("nt",))
        varstdevunrestauzw   = means_stdev_file.createVariable("stdev_unres_tau_zw_sample","f8",("nt",))

        #Store variables
        varmeanuc[:]         = mean_uc[:]
        varmeanvc[:]         = mean_vc[:]
        varmeanwc[:]         = mean_wc[:]
        varmeanunrestauxu[:] = mean_unres_tau_xu[:]
        varmeanunrestauyu[:] = mean_unres_tau_yu[:]
        varmeanunrestauzu[:] = mean_unres_tau_zu[:]
        varmeanunrestauxv[:] = mean_unres_tau_xv[:]
        varmeanunrestauyv[:] = mean_unres_tau_yv[:]
        varmeanunrestauzv[:] = mean_unres_tau_zv[:]
        varmeanunrestauxw[:] = mean_unres_tau_xw[:]
        varmeanunrestauyw[:] = mean_unres_tau_yw[:]
        varmeanunrestauzw[:] = mean_unres_tau_zw[:]

        varstdevuc[:]         = stdev_uc[:]
        varstdevvc[:]         = stdev_vc[:]
        varstdevwc[:]         = stdev_wc[:]
        varstdevunrestauxu[:] = stdev_unres_tau_xu[:]
        varstdevunrestauyu[:] = stdev_unres_tau_yu[:]
        varstdevunrestauzu[:] = stdev_unres_tau_zu[:]
        varstdevunrestauxv[:] = stdev_unres_tau_xv[:]
        varstdevunrestauyv[:] = stdev_unres_tau_yv[:]
        varstdevunrestauzv[:] = stdev_unres_tau_zv[:]
        varstdevunrestauxw[:] = stdev_unres_tau_xw[:]
        varstdevunrestauyw[:] = stdev_unres_tau_yw[:]
        varstdevunrestauzw[:] = stdev_unres_tau_zw[:]

        #Close storage file
        means_stdev_file.close()
